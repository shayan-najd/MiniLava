module Lava.Vhdl
  (vhdl
  )
 where

import Data.Foldable (toList)
import Lava.Signal
import Lava.Netlist
import Lava.Generic
import Lava.Error
import Control.Monad.Writer

import Data.List
  ( intersperse
  )

----------------------------------------------------------------
-- write vhdl

vhdl :: (Constructive a, Generic b) => String -> (a -> b) -> String
vhdl name circ = let inp = var "inp"
                     out = circ inp
                 in  writeDefinitions name inp out
                     (symbolize "outp" out)

----------------------------------------------------------------
-- definitions

writeDefinitions :: (Generic a, Generic b)
                 => String -> a -> b -> b -> String
writeDefinitions name inp out out' =
  let (g , o)  = netgraph out
      outvs = fmap w o
  in   (unlines $
       [ "-- Generated by Lava 2000"
       , ""
       , "use work.all;"
       , ""
       , "entity"
       , "  " ++ name
       , "is"
       , "port"
       , "  -- clock"
       , "  ( " ++ "clk" ++ " : in bit"
       , ""
       , "  -- inputs"
       ] ++
       [ "  ; " ++ v ++ " : in bit"
       | VarBool v <- inps
       ] ++
       [ ""
       , "  -- outputs"
       ] ++
       [ "  ; " ++ v ++ " : out bit"
       | VarBool v <- outs'
       ] ++
       [ "  );"
       , "end entity " ++ name ++ ";"
       , ""
       , "architecture"
       , "  structural"
       , "of"
       , "  " ++ name
       , "is"
       ]) ++
       (concat
       ["  signal " ++ w x ++ " : bit;\n"
       | (x , _) <- g]) ++
       "\n" ++
       (unlines
       [ "begin"
       ]) ++
       (concat
       [snd $ runWriter $ define (w x) (fmap w s)
       | (x , s) <- g]) ++
       (unlines
       [ ""
       , "  -- naming outputs"
       ]) ++
       (concat
       [snd $ runWriter $ define v' (VarBool v)
       | (v,v') <- toList outvs `zip` [ v' | VarBool v' <- outs' ]
       ]) ++
       unlines
       [ "end structural;"
       ]
 where
  w x ="w" ++ show x
  sigs x = map unsymbol . toList . struct $ x

  inps  = sigs inp
  outs' = sigs out'

define :: [Char] -> S [Char] -> Writer String ()
define v s =
           case s of
             Bool True     -> port "vdd"  []
             Bool False    -> port "gnd"  []
             Inv x         -> port "inv"  [x]

             And []        -> define v (Bool True)
             And [x]       -> port "id"   [x]
             And [x,y]     -> port "and2" [x,y]
             And (x:xs)    -> define (w 0) (And xs)
                           >> define v (And [x,w 0])

             Or  []        -> define v (Bool False)
             Or  [x]       -> port "id"   [x]
             Or  [x,y]     -> port "or2"  [x,y]
             Or  (x:xs)    -> define (w 0) (Or xs)
                           >> define v (Or [x,w 0])

             Xor  []       -> define v (Bool False)
             Xor  [x]      -> port "id"   [x]
             Xor  [x,y]    -> port "xor2" [x,y]
             Xor  (x:xs)   -> define (w 0) (Or xs)
                           >> define (w 1) (Inv (w 0))
                           >> define (w 2) (And [x, w 1])

                           >> define (w 3) (Inv x)
                           >> define (w 4) (Xor xs)
                           >> define (w 5) (And [w 3, w 4])
                           >> define v     (Or [w 2, w 5])

             VarBool s'    -> port "id" [s']
             DelayBool x y -> port "delay" [x, y]

             _             -> wrong Lava.Error.NoArithmetic
           where
            w :: Integer -> String
            w i = v ++ "_" ++ show i

            port name' args =
              do tell $
                      "  "
                   ++ make 9 ("c_" ++ v)
                   ++ " : entity "
                   ++ make 5 name'
                   ++ " port map ("
                   ++ concat (intersperse ", " ("clk" : args ++ [v]))
                   ++ ");\n"
            make n ss = take (n `max` length ss) (ss ++ repeat ' ')



----------------------------------------------------------------
-- the end.
